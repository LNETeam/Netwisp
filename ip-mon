--Developed by LNETeam
--Please respect Open Source and due credit
--You can use this utility in your program as long as this banner remains

tArgs = {...}

 function literalize(s)
	return string.gsub("[%(%)%.%%%+%-%*%?%[%]%^%$]",function (c) return "%" .. c end)
end

function lmap(message,sender)
	local net_base = textutils.unserialize(message) --Unserialize the network object
	local net = NetworkCollection.RepairType(net_base,"network") --Repair network object
	
	
	local home = NetworkCollection.new.Computer(net,sender) --Create new computer for (current) host with the global network and parent as parameters

	home:AnalyzeForInterfaces() --Get interfaces

	net:AddComputer(home)
	net:AddCompletedId(os.getComputerID())

	
	for r,t in ipairs(home:GetMountedInterfaces()) do --Foreach interface..

		rednet.open(t:GetSide()) --Open the network

		local found = {rednet.lookup("ip-mon:netwisp")} -- Lookup all computers immediately connected that are ready for a netmap

		if #found > 0 then --Um..
			for k,v in ipairs(found) do --Loop through found clients

				if (not net:ContainsId(v)) then
					rednet.send(v,"request:map", "ip-mon:netwisp") --Send a map request
					local senderId,message,protocol = rednet.receive("ip-mon:netwisp",2) --increase if required
					if senderId ~= nil and message ~= nil then --Ensure that we got a genuine reply
						if senderId == v then --If the computer that was sent to and the reply are the same
							if message == "request:map:yes" then --The computer approves map
								local connection = NetworkCollection.new.AuthenticationBinding(v,os.getComputerID()) --New binding key. This is for future reference that it is indeed the intended host
								rednet.send(v,"request:map:execute","ip-mon:netwisp") --Send execution command
								sleep(0.5) --Wait for client to process

								rednet.send(v,textutils.serialize(net),"ip-mon:netwisp") --Send serialized network object (yes, everything. Could consider sending a new network and merging the, but meh)
								local sId,mge,pr = rednet.receive("ip-mon:netwisp") --Wait for the map to finish. May take a VERY long time depending on the size of the network
								
								if connection:IsMember(sId) then --If the message originated from paired computer
									--net = NetworkCollection.RepairType(mge,"network") --Repair the returned network object to a usable state
									net = textutils.unserialize(mge)
									net = NetworkCollection.RepairType(net,"network")
								end --Untrusted
							end
						end
					end
				end
			end
		end
		rednet.close(t:GetSide()) --Close the side to prevent re-mapping (infinite recursion)
	end
	home:OpenAllInterfaces()
	rednet.send(tonumber(sender),textutils.serialize(net),"ip-mon:netwisp")

	home:CloseAllInterfaces()
	mon()
end

function mon()
	local comp = NetworkCollection.new.Computer(nil) --New temporary computer (to get the mounted interfaces)
	comp:AnalyzeForInterfaces()
	local intfs = comp:GetMountedInterfaces() --Interfaces
	comp:OpenAllInterfaces()
	rednet.host("ip-mon:netwisp","ip-mon:"..math.random()) --Host the waiting map protocol
	local senderId, message, protocol = rednet.receive("ip-mon:netwisp") --Request
	if message ~= nil then --If the message is something
		if message == "request:map" then --If the message is to map
			rednet.send(senderId,"request:map:yes","ip-mon:netwisp") --Send back with a confirmation
			
			local senderId,message,protocol = rednet.receive("ip-mon:netwisp") --Get execution request


			if message == "request:map:execute" then

				local senderId,message,protocol = rednet.receive("ip-mon:netwisp") --sending of network data packet
				comp:CloseAllInterfaces() --Close all interfaces (no more comms with parent, but parent is saved as the sender id which is recovered by using the NetworkCollection.GetComputerByID() method and repaired by NetworkCollection.RepairType())
				lmap(message,senderId)
			end
		end
	end
end

function SaveTable(Table)
   local savedTables = {} -- used to record tables that have been saved, so that we do not go into an infinite recursion
   local outFuncs = {
      ['string']  = function(value) return string.format("%q",value) end;
      ['boolean'] = function(value) if (value) then return 'true' else return 'false' end end;
      ['number']  = function(value) return string.format('%f',value) end;
   }
   local outFuncsMeta = {
      __index = function(t,k) error('Invalid Type For SaveTable: '..k) end      
   }
   setmetatable(outFuncs,outFuncsMeta)
   local tableOut = function(value)
      if (savedTables[value]) then
         error('There is a cyclical reference (table value referencing another table value) in this set.');
      end
      local outValue = function(value) return outFuncs[type(value)](value) end
      local out = '{'
      for i,v in pairs(value) do out = out..'['..outValue(i)..']='..outValue(v)..';' end
      savedTables[value] = true; --record that it has already been saved
      return out..'}'
   end
   outFuncs['table'] = tableOut;
   return tableOut(Table);
end

function LoadTable(Input)
   -- note that this does not enforce anything, for simplicity
   return assert(loadstring('return '..Input))()
end

if fs.exists("netwisp.data/NetworkCollection") then os.loadAPI("netwisp.data/NetworkCollection") else error("missing critical data type...\ncannot continue")end --Ensure they have the proper data type
if #tArgs == 0 then
	error("ip-mon: Expected mode",2) --Need something
elseif  #tArgs == 1 then
	if tArgs[1] == "--imap" then --Network map option
		local net = NetworkCollection.new.Network()--New Global network map object

		net:StartMap() --Begin local and global map
		net:AddCompletedId(os.getComputerID())
		local lcomp = net:GetComputerByID(os.getComputerID())
		lcomp:CloseAllInterfaces()
		if (#lcomp:GetMountedInterfaces() > 0) then --Find "mounted" interfaces
			for k,v in ipairs(net:GetComputerByID(os.getComputerID()):GetMountedInterfaces()) do --Foreach interface..
				rednet.open(v:GetSide()) --Open the network
				
				local found = {rednet.lookup("ip-mon:netwisp")} -- Lookup all computers immediately connected that are ready for a netmap
				if #found > 0 then --Um..
					for k,v in ipairs(found) do --Loop through found clients
						print(net:ContainsId(v))
						if (not net:ContainsId(v)) then
							rednet.send(v,"request:map", "ip-mon:netwisp") --Send a map request
							local senderId,message,protocol = rednet.receive("ip-mon:netwisp",2) --increase if required
							if senderId ~= nil and message ~= nil then --Ensure that we got a genuine reply
								if senderId == v then --If the computer that was sent to and the reply are the same
									if message == "request:map:yes" then --The computer approves map
										local connection = NetworkCollection.new.AuthenticationBinding(v,os.getComputerID()) --New binding key. This is for future reference that it is indeed the intended host
										rednet.send(v,"request:map:execute","ip-mon:netwisp") --Send execution command
										sleep(0.5) --Wait for client to process
										rednet.send(v,textutils.serialize(net),"ip-mon:netwisp") --Send serialized network object (yes, everything. Could consider sending a new network and merging the, but meh)
										local sId,mge,pr = rednet.receive("ip-mon:netwisp") --Wait for the map to finish. May take a VERY long time depending on the size of the network
										
										if connection:IsMember(sId) then --If the message originated from paired computer
											--net = NetworkCollection.RepairType(mge,"network") --Repair the returned network object to a usable state
											net = textutils.unserialize(mge)
											net = NetworkCollection.RepairType(net,"network")
										end --Untrusted
									end
								end
							end
						end
					end
				end
				rednet.close(v:GetSide()) --Close the side to prevent re-mapping (infinite recursion)
			end
			local  handle = io.open("netwisp.data/log_result.log","w")
			handle:write(textutils.serialize(net))
			handle:close()
			
		end
		print("Network map finished. View netobject at: netwisp.data/log_result.log or run 'ip-mon --view' to see user-friendly version. --STOP")
	elseif tArgs[1] == "--view" then
		if fs.exists("netwisp.data/log_result.log") then
			local data = io.open("netwisp.data/log_result.log","r")
			local dt = data:read()
			data:close()
			local mw,mh = term.getSize()
			term.setTextColor(colors.white)
			term.setBackgroundColor(colors.blue)
			term.clear()
			term.setCursorPos(1,1)
			print("Network Topology Map:")
			print("-----------------------------")

		else
			print("No network map file found. Run 'ip-mon --imap' to get network topology")			
		end
	elseif tArgs[1] == "--mon" then --Computer is currently listening
		mon()
	end
elseif #tArgs == 2 then --Mapping in progress.
	if (tArgs[1] == "--mon" and tArgs[2] == "-bg") then
		term.clear()
		term.setCursorPos(1,1)
		local ops = {function() shell.run("shell")end,mon}
		parallel.waitForAny(unpack(ops))
		print("\nMap finished\n")
	elseif (tArgs[1] == "--mon" and tArgs[2] == "-k") then
		
	end
end

--Be3ta

