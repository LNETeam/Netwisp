--Developed by LNETeam
--Please respect Open Source and due credit
--You can use this utility in your program as long as this banner remains

tArgs = {...}
if fs.exists("netwisp.data/NetworkCollection") then os.loadAPI("netwisp.data/NetworkCollection") else error("missing critical data type...\ncannot continue")end --Ensure they have the proper data type
if #tArgs == 0 then
	error("ip-mon: Expected mode",2) --Need something
elseif  #tArgs == 1 then
	if tArgs[1] == "--imap" then --Network map option
		local net = NetworkCollection.new.Network() --New Global network map object
		net:StartMap() --Begin local and global map
		error(textutils.serialize(net))
		if (#net:GetComputerByID(os.GetComputerID()):GetMountedInterfaces() > 0) then --Find "mounted" interfaces
			for k,v in ipairs(net:GetComputerByID(os.GetComputerID()):GetMountedInterfaces()) do --Foreach interface..
				rednet.open(v:GetSide()) --Open the network
				rednet.host("ip-mon:connect","ip-mon") --Host a protocol to prevent discovery looping
				local found = {rednet.lookup("ip-mon:netwisp","ip-mon")} -- Lookup all computers immediately connected that are ready for a netmap
				if #found > 0 then --Um..
					for k,v in ipairs(found) do --Loop through found clients
						rednet.send(v,"request:map", "ip-mon:netwisp") --Send a map request
						local senderId,message,protocol = rednet.recieve("ip-mon:netwisp",2) --increase if required
						if senderId ~= nil and message ~= nil then --Ensure that we got a genuine reply
							if senderId == v then --If the computer that was sent to and the reply are the same
								if message == "request:map:yes" then --The computer approves map
									local connection = NetworkCollection.new.AuthenticationBinding(v,os.GetComputerID()) --New binding key. This is for future reference that it is indeed the intended host
									rednet.send(v,"request:map:execute","ip-mon:netwisp") --Send execution command
									sleep(0.5) --Wait for client to process
									rednet.send(v,textutils.serialize(net),"ip-mon:netwisp") --Send serialized network object (yes, everything. Could consider sending a new network and merging the, but meh)
									local sId,mge,pr = rednet.recieve("ip-mon:netwisp") --Wait for the map to finish. May take a VERY long time depending on the size of the network
									if connection:IsMember(sId) then --If the message originated from paired computer
										net = NetworkCollection.RepairType(mge,"network") --Repair the returned network object to a usable state
									end --Untrusted
								end
							end
						end
					end
				end
				rednet.unhost("ip-mon:connect","ip-mon") --Destroy host
				rednet.close(v.GetSide()) --Close the side to prevent re-mapping (infinite recursion)
			end
			local  handle = io.open("netwisp.data/log_result.log","w")
			handle:write(textutils.serialize(net))
			handle:close()
			print("Network map finished. View netobject at: netwisp.data/log_result.log or run 'ip-mon --view' to see user-friendly version. --STOP")
		end
	elseif tArgs[1] == "--view" then
		if fs.exists("netwisp.data/log_result.log") then
			local data = io.open("netwisp.data/log_result.log","r")
			local dt = data:read()
			data:close()
			local mw,mh = term.getSize()
			term.setTextColor(colors.white)
			term.setBackgroundColor(colors.blue)
			term.clear()
			term.setCursorPos(1,1)
			print("Network Topology Map:")
			print("-----------------------------")

		else
			print("No network map file found. Run 'ip-mon --imap' to get network topology")			
		end
	elseif tArgs[1] == "--mon" then --Computer is currently listening
		local comp = NetworkCollection.new.Computer(nil) --New temporary computer (to get the mounted interfaces)
		comp:AnalyzeForInterfaces()
		--NetworkCollection.writw(textutils.serialize(comp))
		local intfs = comp:GetMountedInterfaces() --Interfaces

		comp:OpenAllInterfaces()
		--if (#intfs > 0) then --Uh..
		--	for k,v in ipairs(intfs) do
		--		rednet.open(v:GetSide()) --Open side
		--	end
		--end --Should have all mounted sides open now
		
		rednet.host("ip-mon:netwisp","ip-mon") --Host the waiting map protocol
		local senderId, message, protocol = rednet.receive("ip-mon:netwisp") --Request
		if message ~= nil then --If the message is something
			if message == "request:map" then --If the message is to map
				rednet.send(senderId,"request:map:yes","ip-mon:netwisp") --Send back with a confirmation
				local senderId,message,protocol = rednet.recieve("ip-mon:netwisp") --Get execution request
				if message == "request:map:execute" then
					local senderId,message,protocol = rednet.recieve("ip-mon:netwisp") --sending of network data packet
					comp:CloseAllInterfaces() --Close all interfaces (no more comms with parent, but parent is saved as the sender id which is recovered by using the NetworkCollection.GetComputerByID() method and repaired by NetworkCollection.RepairType())
					shell.run("ip-mon", "--start",message,senderId) --Begin the map
				end
			end
		end
	end
elseif #tArgs == 3 then --Mapping in progress
	local net_base = textutils.unserialize(tArgs[2]) --Unserialize the network object
	local net = NetworkCollection.RepairType(net_base,"network") --Repair network object

	local home = NetworkCollection.new.Computer(net,net.GetComputerByID(tArgs[3])) --Create new computer for (current) host with the global network and parent as parameters
	home:AnalyzeForInterfaces() --Get interfaces

	net:AddComputer(home)

	for k,v in ipairs(home:GetMountedInterfaces()) do --Foreach interface..
		rednet.open(v:GetSide()) --Open the network
		rednet.host("ip-mon:connect","ip-mon") --Host a protocol to prevent discovery looping
		local found = {rednet.lookUp("ip-mon:netwisp","ip-mon")} -- Lookup all computers immediately connected that are ready for a netmap
		if #found > 0 then --Um..
			for k,v in ipairs(found) do --Loop through found clients
				rednet.send(v,"request:map", "ip-mon:netwisp") --Send a map request
				local senderId,message,protocol = rednet.recieve("ip-mon:netwisp",2) --increase if required
				if senderId ~= nil and message ~= nil then --Ensure that we got a genuine reply
					if senderId == v then --If the computer that was sent to and the reply are the same
						if message == "request:map:yes" then --The computer approves map
							local connection = NetworkCollection.new.AuthenticationBinding(v,os.GetComputerID()) --New binding key. This is for future reference that it is indeed the intended host
							rednet.send(v,"request:map:execute","ip-mon:netwisp") --Send execution command
							sleep(0.5) --Wait for client to process
							rednet.send(v,textutils.serialize(net),"ip-mon:netwisp") --Send serialized network object (yes, everything. Could consider sending a new network and merging the, but meh)
							local sId,mge,pr = rednet.recieve("ip-mon:netwisp") --Wait for the map to finish. May take a VERY long time depending on the size of the network
							if connection.IsMember(sId) then --If the message originated from paired computer
								net = NetworkCollection.RepairType(mge,"network") --Repair the returned network object to a usable state
							end --Untrusted
						end
					end
				end
			end
		end
		rednet.unhost("ip-mon:connect","ip-mon") --Destroy host
		rednet.close(v.GetSide()) --Close the side to prevent re-mapping (infinite recursion)
	end
	host:OpenAllInterfaces()
	local pos = {rednet.lookup("ip-mon:connect")}
	for k,v in ipairs(pos) do
		if v == home.GetParentID() then
			rednet.send(v,textutils.serialize(net),"ip-mon:netwisp")
		end
	end
	host:CloseAllInterfaces()
	shell.run("ip-mon","--mon")
end
